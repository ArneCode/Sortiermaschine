\hypertarget{classCallHandler}{}\doxysection{Call\+Handler Klassenreferenz}
\label{classCallHandler}\index{CallHandler@{CallHandler}}


Ermöglicht es Calls wie z.\+B. Funktionen nacheinander aufzurufen, ohne die delay() Funktion zu verwenden.  




{\ttfamily \#include $<$call\+Handler.\+h$>$}



Zusammengehörigkeiten von Call\+Handler\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=172pt]{classCallHandler__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Öffentliche Methoden}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classCallHandler_a49ab239f771b84300df21bd426788c3e}{delete\+Calls}} ()
\begin{DoxyCompactList}\small\item\em setzt den Speicherplatz der von den Calls besetzt wurde frei \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classCallHandler_afc5654ccaa266f3a81f8230afdb1c2a0}{set\+Calls}} (\mbox{\hyperlink{structCallable}{Callable}} $\ast$new\+Call\+Ptrs\mbox{[}$\,$\mbox{]}, size\+\_\+t n\+Calls)
\begin{DoxyCompactList}\small\item\em Setzt die neuen Calls, die ausgeführt werden sollen. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classCallHandler_ab08a1aaf131e49f7accddb4f981607f9}{$\sim$ Call\+Handler}} ()
\item 
void \mbox{\hyperlink{classCallHandler_a57ff2e7ae3955d5ed4806dcc6469dcf7}{update}} ()
\begin{DoxyCompactList}\small\item\em wechselt zum nächsten Call, wenn der Aktuelle vorbei ist und aktualisiert den jetzigen (z.\+B. animationen) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Öffentliche Attribute}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{classCallHandler_ab56ebeeecd75a34d9fdda13fff68cda7}{running}} = false
\end{DoxyCompactItemize}
\doxysubsection*{Private Attribute}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structCallable}{Callable}} $\ast$$\ast$ \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{call\+Ptrs}}
\begin{DoxyCompactList}\small\item\em Die liste der aktuellen Calls. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structCallable}{Callable}} $\ast$$\ast$ \mbox{\hyperlink{classCallHandler_a090fccd59cdc5b99f5f17f1215c4fd29}{curr\+Call\+Ptr}}
\begin{DoxyCompactList}\small\item\em Der Call der zurzeit ausgeführt wird. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structCallable}{Callable}} $\ast$$\ast$ \mbox{\hyperlink{classCallHandler_a1bb0098f92adc006de8f8cd69c373fb2}{last\+Call\+Ptr}}
\begin{DoxyCompactList}\small\item\em Der letzte Call. \end{DoxyCompactList}\item 
\mbox{\hyperlink{header_8h_a9d1a8265fefddad5533f063ef338d59f}{time\+\_\+t}} \mbox{\hyperlink{classCallHandler_a2c98c2be5b62fafe94b32e3a0f68c84d}{last\+CallT}}
\begin{DoxyCompactList}\small\item\em Der Zeitpunkt an dem der letzte Call ausgeführt wurde. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classCallHandler_a1ee97c59315e54746cef82a406a49236}{calls\+Set}} = false
\begin{DoxyCompactList}\small\item\em Sagt aus, ob \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{Call\+Handler\+::call\+Ptrs}} zu einer gültigen Speicheradresse zeigt. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Ausführliche Beschreibung}
Ermöglicht es Calls wie z.\+B. Funktionen nacheinander aufzurufen, ohne die delay() Funktion zu verwenden. 



Definiert in Zeile 16 der Datei call\+Handler.\+h.



\doxysubsection{Beschreibung der Konstruktoren und Destruktoren}
\mbox{\Hypertarget{classCallHandler_ab08a1aaf131e49f7accddb4f981607f9}\label{classCallHandler_ab08a1aaf131e49f7accddb4f981607f9}} 
\index{CallHandler@{CallHandler}!````~ CallHandler@{$\sim$ CallHandler}}
\index{````~ CallHandler@{$\sim$ CallHandler}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{$\sim$ CallHandler()}{~ CallHandler()}}
{\footnotesize\ttfamily virtual Call\+Handler\+::$\sim$ \mbox{\hyperlink{classCallHandler}{Call\+Handler}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



\doxysubsection{Dokumentation der Elementfunktionen}
\mbox{\Hypertarget{classCallHandler_a49ab239f771b84300df21bd426788c3e}\label{classCallHandler_a49ab239f771b84300df21bd426788c3e}} 
\index{CallHandler@{CallHandler}!deleteCalls@{deleteCalls}}
\index{deleteCalls@{deleteCalls}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{deleteCalls()}{deleteCalls()}}
{\footnotesize\ttfamily void Call\+Handler\+::delete\+Calls (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



setzt den Speicherplatz der von den Calls besetzt wurde frei 



Definiert in Zeile 13 der Datei call\+Handler.\+ino.


\begin{DoxyCode}{0}
\DoxyCodeLine{14 \{}
\DoxyCodeLine{15   \textcolor{keywordflow}{if} (!\mbox{\hyperlink{classCallHandler_a1ee97c59315e54746cef82a406a49236}{callsSet}}) \{}
\DoxyCodeLine{16     \textcolor{keywordflow}{return};}
\DoxyCodeLine{17   \}}
\DoxyCodeLine{18   \mbox{\hyperlink{classCallHandler_a1ee97c59315e54746cef82a406a49236}{callsSet}} = \textcolor{keyword}{false};}
\DoxyCodeLine{19   \textcolor{keywordflow}{for} (\mbox{\hyperlink{structCallable}{Callable}}** callPtr = \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{callPtrs}}; callPtr <= \mbox{\hyperlink{classCallHandler_a1bb0098f92adc006de8f8cd69c373fb2}{lastCallPtr}}; callPtr++) \{}
\DoxyCodeLine{20     \textcolor{keyword}{delete} *callPtr;}
\DoxyCodeLine{21   \}}
\DoxyCodeLine{22   \textcolor{keyword}{delete} \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{callPtrs}};}
\DoxyCodeLine{23 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classCallHandler_afc5654ccaa266f3a81f8230afdb1c2a0}\label{classCallHandler_afc5654ccaa266f3a81f8230afdb1c2a0}} 
\index{CallHandler@{CallHandler}!setCalls@{setCalls}}
\index{setCalls@{setCalls}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{setCalls()}{setCalls()}}
{\footnotesize\ttfamily void Call\+Handler\+::set\+Calls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structCallable}{Callable}} $\ast$}]{new\+Call\+Ptrs\mbox{[}$\,$\mbox{]},  }\item[{size\+\_\+t}]{n\+Calls }\end{DoxyParamCaption})}



Setzt die neuen Calls, die ausgeführt werden sollen. 

\begin{DoxyWarning}{Warnung}
n\+Calls darf auf keinen Fall größer als die tatsächliche Anzahl an Calls sein, sonst stürzt das Programm ab 
\end{DoxyWarning}

\begin{DoxyParams}{Parameter}
{\em new\+Call\+Ptrs} & \\
\hline
{\em n\+Calls} & \\
\hline
\end{DoxyParams}


Definiert in Zeile 30 der Datei call\+Handler.\+ino.


\begin{DoxyCode}{0}
\DoxyCodeLine{31 \{}
\DoxyCodeLine{32   \textcolor{comment}{/*if(callsSet)\{ //doing this would result in two sets of calls being in heap at once}}
\DoxyCodeLine{33 \textcolor{comment}{    deleteCalls(); //solution is to delete previus calls before initializing a new one}}
\DoxyCodeLine{34 \textcolor{comment}{  \}*/}}
\DoxyCodeLine{35   \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{callPtrs}} = newCallPtrs;}
\DoxyCodeLine{36   \mbox{\hyperlink{classCallHandler_a1ee97c59315e54746cef82a406a49236}{callsSet}} = \textcolor{keyword}{true};}
\DoxyCodeLine{37   \mbox{\hyperlink{classCallHandler_a090fccd59cdc5b99f5f17f1215c4fd29}{currCallPtr}} = \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{callPtrs}};}
\DoxyCodeLine{38   (*currCallPtr)-\/>\mbox{\hyperlink{structCallable_a0e146c329fbdf8720a9541f60fe910e9}{run}}();}
\DoxyCodeLine{39   \mbox{\hyperlink{classCallHandler_a1bb0098f92adc006de8f8cd69c373fb2}{lastCallPtr}} = \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{callPtrs}} + nCalls -\/ 1;}
\DoxyCodeLine{40   \mbox{\hyperlink{classCallHandler_a2c98c2be5b62fafe94b32e3a0f68c84d}{lastCallT}} = millis();}
\DoxyCodeLine{41   \mbox{\hyperlink{classCallHandler_ab56ebeeecd75a34d9fdda13fff68cda7}{running}} = \textcolor{keyword}{true};}
\DoxyCodeLine{42 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classCallHandler_a57ff2e7ae3955d5ed4806dcc6469dcf7}\label{classCallHandler_a57ff2e7ae3955d5ed4806dcc6469dcf7}} 
\index{CallHandler@{CallHandler}!update@{update}}
\index{update@{update}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{update()}{update()}}
{\footnotesize\ttfamily void Call\+Handler\+::update (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



wechselt zum nächsten Call, wenn der Aktuelle vorbei ist und aktualisiert den jetzigen (z.\+B. animationen) 

wird von loop aufgerufen 

Definiert in Zeile 47 der Datei call\+Handler.\+ino.


\begin{DoxyCode}{0}
\DoxyCodeLine{48 \{}
\DoxyCodeLine{49   \textcolor{keywordflow}{if} (!\mbox{\hyperlink{classCallHandler_ab56ebeeecd75a34d9fdda13fff68cda7}{running}}) \{}
\DoxyCodeLine{50     \textcolor{keywordflow}{return};}
\DoxyCodeLine{51   \}}
\DoxyCodeLine{52   \mbox{\hyperlink{header_8h_a9d1a8265fefddad5533f063ef338d59f}{time\_t}} timePassed = millis() -\/ \mbox{\hyperlink{classCallHandler_a2c98c2be5b62fafe94b32e3a0f68c84d}{lastCallT}};}
\DoxyCodeLine{53   \textcolor{keywordflow}{if} ((*currCallPtr)-\/>isDone()) \{\textcolor{comment}{//-\/>currCall-\/>isDone()}}
\DoxyCodeLine{54     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classCallHandler_a090fccd59cdc5b99f5f17f1215c4fd29}{currCallPtr}} == \mbox{\hyperlink{classCallHandler_a1bb0098f92adc006de8f8cd69c373fb2}{lastCallPtr}}) \{}
\DoxyCodeLine{55       \mbox{\hyperlink{classCallHandler_ab56ebeeecd75a34d9fdda13fff68cda7}{running}} = \textcolor{keyword}{false};}
\DoxyCodeLine{56       \textcolor{keywordflow}{return};}
\DoxyCodeLine{57     \}}
\DoxyCodeLine{58     \mbox{\hyperlink{classCallHandler_a090fccd59cdc5b99f5f17f1215c4fd29}{currCallPtr}}++;}
\DoxyCodeLine{59     (*currCallPtr)-\/>\mbox{\hyperlink{structCallable_a0e146c329fbdf8720a9541f60fe910e9}{run}}();\textcolor{comment}{//-\/>currCall-\/>run();}}
\DoxyCodeLine{60   \}}
\DoxyCodeLine{61 \}}

\end{DoxyCode}


\doxysubsection{Dokumentation der Datenelemente}
\mbox{\Hypertarget{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}\label{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}} 
\index{CallHandler@{CallHandler}!callPtrs@{callPtrs}}
\index{callPtrs@{callPtrs}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{callPtrs}{callPtrs}}
{\footnotesize\ttfamily \mbox{\hyperlink{structCallable}{Callable}}$\ast$$\ast$ Call\+Handler\+::call\+Ptrs\hspace{0.3cm}{\ttfamily [private]}}



Die liste der aktuellen Calls. 

Wird mithilfe von \mbox{\hyperlink{classCallHandler_afc5654ccaa266f3a81f8230afdb1c2a0}{Call\+Handler\+::set\+Calls}} gesetzt. Die Calls werden im Heap gespeichert, das heißt zum einen, dass sie zwischen Funktionen hin-\/ und hergegeben werden können, zum anderen aber auch, dass sie mithilfe von \mbox{\hyperlink{classCallHandler_a49ab239f771b84300df21bd426788c3e}{Call\+Handler\+::delete\+Calls}} manuell wieder gelöscht werden müssen 

Definiert in Zeile 22 der Datei call\+Handler.\+h.

\mbox{\Hypertarget{classCallHandler_a1ee97c59315e54746cef82a406a49236}\label{classCallHandler_a1ee97c59315e54746cef82a406a49236}} 
\index{CallHandler@{CallHandler}!callsSet@{callsSet}}
\index{callsSet@{callsSet}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{callsSet}{callsSet}}
{\footnotesize\ttfamily bool Call\+Handler\+::calls\+Set = false\hspace{0.3cm}{\ttfamily [private]}}



Sagt aus, ob \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{Call\+Handler\+::call\+Ptrs}} zu einer gültigen Speicheradresse zeigt. 



Definiert in Zeile 43 der Datei call\+Handler.\+h.

\mbox{\Hypertarget{classCallHandler_a090fccd59cdc5b99f5f17f1215c4fd29}\label{classCallHandler_a090fccd59cdc5b99f5f17f1215c4fd29}} 
\index{CallHandler@{CallHandler}!currCallPtr@{currCallPtr}}
\index{currCallPtr@{currCallPtr}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{currCallPtr}{currCallPtr}}
{\footnotesize\ttfamily \mbox{\hyperlink{structCallable}{Callable}}$\ast$$\ast$ Call\+Handler\+::curr\+Call\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Der Call der zurzeit ausgeführt wird. 

Es handelt sich hierbei um einen Pointer-\/\+Pointer. Der Pointer zeigt zu einer Stelle in der \mbox{\hyperlink{classCallHandler_a70bf3c03de1953c55fc468b73c77e0f2}{Call\+Handler\+::call\+Ptrs}} Liste, die wiederum zum tatsächlichen Call zeigt 

Definiert in Zeile 28 der Datei call\+Handler.\+h.

\mbox{\Hypertarget{classCallHandler_a1bb0098f92adc006de8f8cd69c373fb2}\label{classCallHandler_a1bb0098f92adc006de8f8cd69c373fb2}} 
\index{CallHandler@{CallHandler}!lastCallPtr@{lastCallPtr}}
\index{lastCallPtr@{lastCallPtr}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{lastCallPtr}{lastCallPtr}}
{\footnotesize\ttfamily \mbox{\hyperlink{structCallable}{Callable}}$\ast$$\ast$ Call\+Handler\+::last\+Call\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Der letzte Call. 

Wird benutzt um zu wissen, wann der letzte Call ausgeführt wurde 

Definiert in Zeile 33 der Datei call\+Handler.\+h.

\mbox{\Hypertarget{classCallHandler_a2c98c2be5b62fafe94b32e3a0f68c84d}\label{classCallHandler_a2c98c2be5b62fafe94b32e3a0f68c84d}} 
\index{CallHandler@{CallHandler}!lastCallT@{lastCallT}}
\index{lastCallT@{lastCallT}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{lastCallT}{lastCallT}}
{\footnotesize\ttfamily \mbox{\hyperlink{header_8h_a9d1a8265fefddad5533f063ef338d59f}{time\+\_\+t}} Call\+Handler\+::last\+CallT\hspace{0.3cm}{\ttfamily [private]}}



Der Zeitpunkt an dem der letzte Call ausgeführt wurde. 



Definiert in Zeile 38 der Datei call\+Handler.\+h.

\mbox{\Hypertarget{classCallHandler_ab56ebeeecd75a34d9fdda13fff68cda7}\label{classCallHandler_ab56ebeeecd75a34d9fdda13fff68cda7}} 
\index{CallHandler@{CallHandler}!running@{running}}
\index{running@{running}!CallHandler@{CallHandler}}
\doxysubsubsection{\texorpdfstring{running}{running}}
{\footnotesize\ttfamily bool Call\+Handler\+::running = false}



Definiert in Zeile 46 der Datei call\+Handler.\+h.



Die Dokumentation für diese Klasse wurde erzeugt aufgrund der Dateien\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{callHandler_8h}{call\+Handler.\+h}}\item 
\mbox{\hyperlink{callHandler_8ino}{call\+Handler.\+ino}}\end{DoxyCompactItemize}
